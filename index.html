<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>JIGI v0.5.7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --primary:#1976D2; --text:#232323; --muted:#9E9E9E; --bg:#FFFFFF; --chip:#F2F6FA; --ad:#E0E0E0; }
    *{box-sizing:border-box}
    body{ margin:0; background:var(--bg); color:var(--text); font-family:Pretendard, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; display:flex; flex-direction:column; align-items:center; min-height:100svh;}
    header{ width:100%; padding:18px 20px 8px; text-align:center; position:relative }
    h1{ margin:0; font-size:24px; color:var(--primary) }
    #settingsBtn{ position:absolute; right:16px; top:16px; background:none; border:none; font-size:20px; cursor:pointer }
    .headline{ width:92%; max-width:720px; margin:10px auto 0; font-size:17px; line-height:1.5; text-align:left; min-height:52px }
    .wrap{ width:100%; max-width:720px; display:flex; flex-direction:column; align-items:center }
    .toolbar{ width:92%; display:flex; justify-content:space-between; align-items:center; gap:8px; margin:10px 0 6px }
    .loc{ font-size:12px; color:#666; min-height:18px }
    .btn{ padding:8px 10px; border:none; border-radius:10px; background:#EEF4FF; color:var(--primary); font-weight:600; font-size:12px; cursor:pointer }
    .toggle{ display:inline-flex; background:#EFF3F9; border-radius:12px; padding:2px; gap:2px }
    .tgbtn{ border:none; background:transparent; padding:6px 10px; border-radius:10px; font-size:12px; color:#555; cursor:pointer }
    .tgbtn.active{ background:#fff; color:#000; box-shadow:0 1px 3px rgba(0,0,0,0.08) }
    .chips{ display:flex; gap:8px; margin:10px 0 2px; padding:0 16px; flex-wrap:wrap; justify-content:flex-start; width:92%; min-height:36px }
    .chip{ padding:8px 12px; border-radius:16px; background:var(--chip); color:var(--text); font-size:14px }
    .chip.active{ background:var(--primary); color:#fff }
    #chart-wrap{ width:92%; height:160px; margin:8px 0 }
    canvas{ width:100% !important; height:100% !important; }
    .ad{ width:100%; height:100px; background:var(--ad); margin-top:auto; display:flex; align-items:center; justify-content:center; color:#555; font-size:14px }
    .toast{ position:fixed; top:8px; left:50%; transform:translateX(-50%); background:#000a; color:#fff; padding:6px 10px; border-radius:8px; font-size:12px; display:none; z-index:99 }
    /* Settings panel & overlay */
    #overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.32); display:none; z-index:150 }
    #overlay.show{ display:block }
    #settingsPanel{ position:fixed; top:0; right:-320px; width:280px; height:100%; background:#fff; box-shadow:-2px 0 6px rgba(0,0,0,0.15); transition: right 0.25s ease; padding:20px; overflow-y:auto; z-index:200 }
    #settingsPanel.open{ right:0 }
    #settingsPanel h2{ font-size:16px; margin-top:0; color:var(--primary) }
    #settingsPanel label{ display:block; margin:10px 0 4px; font-size:13px; font-weight:600 }
    #settingsPanel select{ width:100%; padding:6px; font-size:13px; margin-bottom:12px }
    #settingsPanel .info{ font-size:12px; color:#555; margin-top:12px }
    /* Skeletons */
    .skeleton{ background: linear-gradient(90deg, #eee 25%, #f6f6f6 37%, #eee 63%); background-size: 400% 100%; animation: shimmer 1.2s infinite; border-radius:8px }
    @keyframes shimmer{ 0%{background-position:100% 0} 100%{background-position:-100% 0} }
    .sk-head{ width:92%; height:48px; margin-top:10px }
    .retry{ display:none; margin:8px 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="toast" id="toast"></div>
  <div id="overlay"></div>
  <header>
    <h1>JIGI</h1>
    <button id="settingsBtn">⚙️</button>
  </header>
  <div class="headline" id="headline"><span class="skeleton sk-head"></span></div>

  <div class="wrap">
    <div class="toolbar">
      <div class="loc" id="locLabel">위치 확인 중…</div>
      <div style="display:flex; gap:8px; align-items:center">
        <div class="toggle">
          <button class="tgbtn active" id="tgToday">오늘</button>
          <button class="tgbtn" id="tgTomorrow">내일</button>
        </div>
        <button class="btn" id="btnRefresh">새로고침</button>
      </div>
    </div>
    <div class="chips" id="chips"></div>
    <div id="chart-wrap">
      <canvas id="weatherChart"></canvas>
    </div>
    <button id="retryBtn" class="btn retry">다시 시도</button>
  </div>

  <div class="ad">Ad banner (320×100)</div>

  <!-- Settings Panel -->
  <div id="settingsPanel">
    <h2>설정</h2>
    <label for="langSelect">언어</label>
    <select id="langSelect">
      <option value="ko">한국어</option>
      <option value="en">English</option>
      <option value="ja">日本語</option>
    </select>
    <label for="toneSelect">말투</label>
    <select id="toneSelect">
      <option value="friend">친구 톤</option>
      <option value="butler">집사 톤</option>
      <option value="formal">격식 톤</option>
      <option value="god">날씨의 신</option>
    </select>
    <div class="info">
      <p><b>앱 이름</b>: JIGI</p>
      <p><b>버전</b>: v0.5.7</p>
      <p><b>만든 사람</b>: 류재영</p>
      <p><b>이메일</b>: nolittleprince@gmail.com</p>
      <p><b>Instagram</b>: @nolittle.prince</p>
    </div>
  </div>

<script>
const state = { view:'today', data:null, lang:'ko', tone:'friend', locationName:'' };
const toast = (msg)=>{ const el=document.getElementById('toast'); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',2400); };

// ---------- Utils ----------
function fmt(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function getDates(){ const now=new Date(); const today=new Date(now.getFullYear(),now.getMonth(),now.getDate()); const yest=new Date(today); yest.setDate(yest.getDate()-1); const tomo=new Date(today); tomo.setDate(tomo.getDate()+1); return {today:fmt(today), yesterday:fmt(yest), tomorrow:fmt(tomo)}; }
function withTimeout(promise, ms, label="요청"){ const ctrl = new AbortController(); const timer = setTimeout(()=>ctrl.abort(), ms); return Promise.race([ fetchPromiseWithSignal(promise, ctrl.signal), timeoutReject(ms, label) ]).finally(()=>clearTimeout(timer)); }
async function fetchPromiseWithSignal(promise, signal){ const res = await promise(signal); return res; }
function timeoutReject(ms, label){ return new Promise((_,rej)=> setTimeout(()=> rej(new Error(label+" 시간초과")), ms)); }

// ---------- API ----------
async function fetchWeather(lat, lon){
  const { today, tomorrow, yesterday } = getDates();
  const base = "https://api.open-meteo.com/v1/forecast";
  const paramsTD = new URLSearchParams({ latitude:lat, longitude:lon, hourly:"temperature_2m,dewpoint_2m,windspeed_10m,precipitation_probability,uv_index", daily:"uv_index_max,temperature_2m_max,temperature_2m_min", timezone:"auto", start_date:today, end_date:tomorrow });
  const paramsY = new URLSearchParams({ latitude:lat, longitude:lon, hourly:"temperature_2m", timezone:"auto", start_date:yesterday, end_date:yesterday });

  const fetch1 = () => fetch(`${base}?${paramsTD}`);
  const fetch2 = () => fetch(`${base}?${paramsY}`);

  const [resTD, resY] = await Promise.all([ withTimeout(fetch1, 7000, "날씨"), withTimeout(fetch2, 7000, "어제날씨") ]);
  if (!resTD.ok || !resY.ok) throw new Error("데이터 로드 실패");
  return { td: await resTD.json(), y: await resY.json() };
}

async function fetchLocationName(lat, lon, lang){
  try{
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&accept-language=${lang}`;
    const res = await withTimeout((signal)=> fetch(url, {signal}), 3500, "지명");
    if(!res.ok) return "";
    const data = await res.json();
    const a = data.address || {};
    return a.city || a.town || a.village || a.county || data.display_name || "";
  }catch(e){ return ""; }
}

// ---------- Data helpers ----------
const buckets=[{name:"아침",range:[6,11]},{name:"점심",range:[12,16]},{name:"저녁",range:[17,20]},{name:"밤",range:[21,23],alt:[0,5]}];
function avg(arr,s,e){const a=arr.slice(s,e+1);return a.reduce((x,y)=>x+y,0)/a.length;}
function avgBucket(arr,{range,alt}){const main=avg(arr,range[0],range[1]); if(!alt)return main; const a=avg(arr,alt[0],alt[1]); return (main*3+a*1)/4;}
function splitByDate(hourly){const map={}; hourly.time.forEach((iso,i)=>{const d=new Date(iso); const key=fmt(new Date(d.getFullYear(),d.getMonth(),d.getDate())); (map[key]||(map[key]=[])).push(i);}); return map;}
function pickDay(td,dateStr){const h=td.hourly; const groups=splitByDate(h); const idxs=groups[dateStr]; if(!idxs)return null; const pick=(arr)=>arr?idxs.map(i=>arr[i]):[]; return {t:pick(h.temperature_2m),dp:pick(h.dewpoint_2m),wind:pick(h.windspeed_10m),rain:pick(h.precipitation_probability),uvh:pick(h.uv_index),uvmax:td.daily?.uv_index_max?.[(td.daily.time||[]).indexOf(dateStr)]??null,tmax:td.daily?.temperature_2m_max?.[(td.daily.time||[]).indexOf(dateStr)]??null,tmin:td.daily?.temperature_2m_min?.[(td.daily.time||[]).indexOf(dateStr)]??null};}

// ---------- Solar terms (24절기) ----------
// Approximate ranges by month/day (KST). Kept simple for MVP.
const SOLAR_KO=[
  {m:2,d:4, n:"입춘"},{m:2,d:19,n:"우수"},{m:3,d:5,n:"경칩"},{m:3,d:20,n:"춘분"},{m:4,d:4,n:"청명"},{m:4,d:20,n:"곡우"},
  {m:5,d:5,n:"입하"},{m:5,d:21,n:"소만"},{m:6,d:5,n:"망종"},{m:6,d:21,n:"하지"},{m:7,d:7,n:"소서"},{m:7,d:23,n:"대서"},
  {m:8,d:7,n:"입추"},{m:8,d:23,n:"처서"},{m:9,d:7,n:"백로"},{m:9,d:23,n:"추분"},{m:10,d:8,n:"한로"},{m:10,d:24,n:"상강"},
  {m:11,d:7,n:"입동"},{m:11,d:22,n:"소설"},{m:12,d:7,n:"대설"},{m:12,d:22,n:"동지"},{m:1,d:6,n:"소한"},{m:1,d:20,n:"대한"}
];
const SOLAR_EN={
  "입춘":"Start of Spring","우수":"Rain Water","경칩":"Waking of Insects","춘분":"Spring Equinox","청명":"Clear and Bright","곡우":"Grain Rain",
  "입하":"Start of Summer","소만":"Lesser Fullness","망종":"Grain in Ear","하지":"Summer Solstice","소서":"Lesser Heat","대서":"Greater Heat",
  "입추":"Start of Autumn","처서":"Limit of Heat","백로":"White Dew","추분":"Autumn Equinox","한로":"Cold Dew","상강":"Frost Descent",
  "입동":"Start of Winter","소설":"Lesser Snow","대설":"Greater Snow","동지":"Winter Solstice","소한":"Lesser Cold","대한":"Greater Cold"
};
const SOLAR_JA={
  "입춘":"立春","우수":"雨水","경칩":"啓蟄","춘분":"春分","청명":"清明","곡우":"穀雨",
  "입하":"立夏","소만":"小満","망종":"芒種","하지":"夏至","소서":"小暑","대서":"大暑",
  "입추":"立秋","처서":"処暑","백로":"白露","추분":"秋分","한로":"寒露","상강":"霜降",
  "입동":"立冬","소설":"小雪","대설":"大雪","동지":"冬至","소한":"小寒","대한":"大寒"
};
function solarTerm(today, lang){
  // find last term before or equal today
  const y=today.getFullYear();
  const list=SOLAR_KO.map(t=>({date:new Date(y, t.m-1, t.d), n:t.n})).sort((a,b)=>a.date-b.date);
  // handle Jan terms (소한/대한): if today in Jan before Jan20 adjust
  const janTerms=list.filter(t=> t.date.getMonth()===0);
  const all=list.concat(); all.sort((a,b)=>a.date-b.date);
  let cur=all[0];
  for(const t of all){ if(today>=t.date) cur=t; }
  const name=cur.n;
  if(lang==='ko') return name;
  if(lang==='en') return SOLAR_EN[name] || name;
  if(lang==='ja') return SOLAR_JA[name] || name;
  return name;
}

// ---------- Headline (tones & phrasing fix) ----------
function buildHeadline(day,ref,mode,tone,lang){
  const tAvg = day.t.reduce((a,b)=>a+b,0)/day.t.length;
  const rAvg = ref.t.reduce((a,b)=>a+b,0)/ref.t.length;
  const delta = tAvg - rAvg;
  const abs = Math.abs(delta);

  const dp = day.dp.length ? avg(day.dp,12,15) : null;
  const rain = day.rain.length ? avg(day.rain,12,15) : 0;
  const wind = day.wind.length ? avg(day.wind,12,15) : 0;
  const uv = day.uvh.length ? avg(day.uvh,11,13) : (day.uvmax ?? 0);

  // --- temperature phrase with grammar fix ---
  let lead="";
  const baseToday   = (lang==='ko')? "오늘은 어제랑" : (lang==='ja'?"今日は昨日と":"Today vs Yesterday");
  const baseTomorrow= (lang==='ko')? "내일도 오늘이랑" : (lang==='ja'?"明日も今日と":"Tomorrow vs Today");
  const compToday   = (lang==='ko')? "오늘은 어제보다" : (lang==='ja'?"今日は昨日より":"Today than Yesterday");
  const compTomorrow= (lang==='ko')? "내일은 오늘보다" : (lang==='ja'?"明日は今日より":"Tomorrow than Today");

  const samePhrases = (lang==='ko')? ["거의 같아요","큰 차이 없어요"] :
                      (lang==='ja')? ["ほぼ同じです","大きな差はありません"] :
                                      ["about the same","no big change"];
  const smallUp     = (lang==='ko')? "조금 더 포근해요" : (lang==='ja'?"少し暖かいです":"a bit warmer");
  const smallDown   = (lang==='ko')? "살짝 서늘하네요" : (lang==='ja'?"少し涼しいです":"a bit cooler");
  const bigUp       = (lang==='ko')? "확실히 따뜻해요" : (lang==='ja'?"はっきり暖かいです":"noticeably warmer");
  const bigDown     = (lang==='ko')? "확실히 선선해요" : (lang==='ja'?"はっきり涼しいです":"noticeably cooler");

  if (abs <= 0.5){
    const base = (mode==='today') ? baseToday : baseTomorrow;
    lead = `${base} ${samePhrases[ Math.floor(Math.random()*samePhrases.length) ]}`;
  } else if (abs <= 1.5){
    const base = (mode==='today') ? compToday : compTomorrow;
    lead = `${base} ${delta>0 ? smallUp : smallDown}`;
  } else {
    const base = (mode==='today') ? compToday : compTomorrow;
    lead = `${base} ${delta>0 ? bigUp : bigDown}`;
  }

  // humidity / wind / uv / rain tone (short)
  const humidTone = (dp===null) ? (lang==='ko'?"상쾌해요":(lang==='ja'?"さわやかです":"feels fresh"))
                     : (dp>=24 ? (lang==='ko'?"많이 끈적해요":(lang==='ja'?"かなり蒸し暑いです":"very muggy"))
                     : (dp>=22 ? (lang==='ko'?"좀 습해요":(lang==='ja'?"少し蒸します":"quite humid"))
                     : (dp>=19 ? (lang==='ko'?"살짝 습해요":(lang==='ja'?"やや湿っぽいです":"slightly humid"))
                               : (lang==='ko'?"상쾌해요":(lang==='ja'?"さわやかです":"fresh"))));

  let windTone = ""; if (wind>=8) windTone = (lang==='ko')?"바람이 강해요":(lang==='ja'?"風が強いです":"windy");
  else if (wind>=5) windTone = (lang==='ko')?"바람이 조금 불어요":(lang==='ja'?"やや風があります":"a bit breezy");

  let uvTone = (uv>=8)? ((lang==='ko')?"자외선 매우 강해요":(lang==='ja'?"紫外線がとても強いです":"UV very high"))
             : (uv>=6)? ((lang==='ko')?"자외선이 강해요":(lang==='ja'?"紫外線が強いです":"UV high"))
             : (uv>=3)? ((lang==='ko')?"자외선 보통이에요":(lang==='ja'?"紫外線は普通です":"UV moderate"))
                      : ((lang==='ko')?"자외선 낮아요":(lang==='ja'?"紫外線は低いです":"UV low"));

  const rainTone = (rain>=60)? ((lang==='ko')?"비 올 수도 있어요":(lang==='ja'?"雨の可能性があります":"chance of rain"))
                              : ((lang==='ko')?"비 걱정은 없어요":(lang==='ja'?"雨の心配はありません":"no rain expected"));

  // seasonal note
  const term = solarTerm(new Date(), state.lang);
  const termTxt = (lang==='ko') ? `지금은 ${term}이에요.`
                : (lang==='ja') ? `今は「${term}」の頃です。`
                                : `Now around "${(SOLAR_EN[term]||term)}".`;

  // tone templates
  const combine = (a,b,c,d) => {
    const parts=[a,b,c,d].filter(Boolean);
    return parts.join(" ");
  };

  const friend = combine(lead, humidTone, windTone, `${uvTone}. ${rainTone} ${termTxt}`);
  const butler = combine(lead, (lang==='ko'?"공기는 ":"空気は ")+(humidTone.replace("요","")+ (lang==='ko'?"입니다.":"。")), windTone ? windTone+(lang==='ko'?" ":"。"):"", `${uvTone}. ${rainTone} ${termTxt}`);
  const formal = combine(lead, (lang==='ko'?"공기는 ":"空気は ")+(humidTone.replace("요","")+ (lang==='ko'?"입니다.":"。")), windTone ? windTone+(lang==='ko'?" ":"。"):"", `${uvTone}. ${rainTone} ${termTxt}`);
  const god    = combine(lead+(lang==='ko'?"":"."), (lang==='ko'?"공기 기운이 ":"空気の気配は ")+humidTone+(lang==='ko'?"도다.":"。"), windTone? (windTone+(lang==='ko'?"도다.":"。")):"", `${uvTone}. ${rainTone} ${termTxt}`);

  const map = { friend, butler, formal, god };
  return map[tone] || friend;
}

// ---------- Chart ----------
function drawChart(seriesBase,seriesCompare,viewMode){
  const ctx=document.getElementById('weatherChart');
  const labels=["아침","점심","저녁","밤"];
  const nowH=new Date().getHours(); let nowIdx=3;
  if(nowH>=6&&nowH<=11)nowIdx=0; else if(nowH>=12&&nowH<=16)nowIdx=1; else if(nowH>=17&&nowH<=20)nowIdx=2;

  const nowLinePlugin={ id:'nowLine', afterDatasetsDraw(chart){ if(viewMode!=='today')return; const {ctx,chartArea:{top,bottom},scales:{x}}=chart; const pos=x.getPixelForValue(nowIdx); ctx.save(); ctx.lineWidth=1.2; ctx.strokeStyle='red'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(pos, top); ctx.lineTo(pos, bottom); ctx.stroke(); ctx.restore(); } };

  if(window.__jigiChart){ window.__jigiChart.destroy(); }
  window.__jigiChart=new Chart(ctx,{
    type:'line',
    data:{ labels, datasets:[
      {label:'기준', data:seriesBase, tension:0.35, borderColor:'#B0BEC5', pointRadius:2 },
      {label:'비교', data:seriesCompare, tension:0.35, borderColor:getComputedStyle(document.documentElement).getPropertyValue('--primary').trim(), pointRadius:3 }
    ]},
    options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false } },
      layout:{ padding:{ left:6, right:6, top:2, bottom:0 } },
      scales:{ x:{ grid:{ display:false } }, y:{ grid:{ color:'#ECEFF1' }, ticks:{ maxTicksLimit:4, callback:(v)=> v+'°' } } },
      animation:false
    },
    plugins:[nowLinePlugin]
  });
}

// ---------- App flow ----------
async function init(lat,lon,label=""){
  document.getElementById('locLabel').textContent = label || `위치 확인 중…`;
  document.getElementById('headline').innerHTML = '<span class="skeleton sk-head"></span>';
  document.getElementById('retryBtn').style.display='none';

  try{
    const { td, y } = await fetchWeather(lat, lon);
    state.data = { td, y };
    render();
    fetchLocationName(lat, lon, state.lang).then(name=>{
      if(name){ state.locationName=name; document.getElementById('locLabel').textContent = name; }
      else if(label){ document.getElementById('locLabel').textContent = label; }
    });
  }catch(e){
    console.error(e);
    document.getElementById('headline').textContent = "네트워크가 느려요. 다시 시도해볼까요?";
    document.getElementById('retryBtn').style.display='inline-block';
  }
}

function render(){
  const { today, tomorrow } = getDates();
  const td=state.data.td, y=state.data.y;
  const todayArr=pickDay(td,today);
  const tomorrowArr=pickDay(td,tomorrow);
  const yestArr={ t: y.hourly.temperature_2m };

  let head, baseSeries, compSeries;
  if(state.view==='today'){
    head = buildHeadline(todayArr, yestArr, "today", state.tone, state.lang);
    baseSeries = buckets.map(b=>avgBucket(yestArr.t,b));
    compSeries = buckets.map(b=>avgBucket(todayArr.t,b));
  }else{
    head = buildHeadline(tomorrowArr, todayArr, "tomorrow", state.tone, state.lang);
    baseSeries = buckets.map(b=>avgBucket(todayArr.t,b));
    compSeries = buckets.map(b=>avgBucket(tomorrowArr.t,b));
  }
  document.getElementById('headline').textContent = head;

  drawChart(baseSeries, compSeries, state.view);

  // Tip chips (light)
  const chipsEl=document.getElementById('chips'); chipsEl.innerHTML="";
  const dp = (state.view==='today'? avg(todayArr.dp,12,15) : avg(tomorrowArr.dp,12,15));
  const rain = (state.view==='today'? avg(todayArr.rain,12,15) : avg(tomorrowArr.rain,12,15));
  const wind = (state.view==='today'? avg(todayArr.wind,12,15) : avg(tomorrowArr.wind,12,15));
  const uvh  = (state.view==='today'? (todayArr.uvh.length? avg(todayArr.uvh,11,13):todayArr.uvmax) : (tomorrowArr.uvh.length? avg(tomorrowArr.uvh,11,13):tomorrowArr.uvmax));

  const chips=[];
  if(dp && dp>=19) chips.push("🧵 통풍 좋은 옷");
  if(rain && rain>=60) chips.push("☂ 우산 챙기기");
  if(wind && wind>=7) chips.push("🧥 바람막이");
  if(uvh && uvh>=7) chips.push("🧴 선크림/모자");
  Array.from(new Set(chips)).slice(0,3).forEach((t,i)=>{
    const d=document.createElement('div'); d.className='chip'+(i===0?' active':''); d.textContent=t; chipsEl.appendChild(d);
  });
}

// ---------- Geolocation & UI ----------
function useGeolocation(){
  if(!navigator.geolocation){
    toast("위치 기능을 사용할 수 없어요. 서울로 보여드릴게요.");
    init(37.5665,126.9780,"서울(기본)");
    return;
  }
  navigator.geolocation.getCurrentPosition(
    (pos)=>{ const { latitude:lat, longitude:lon } = pos.coords; init(lat, lon); },
    (err)=>{ toast("위치 권한이 없어 서울로 보여드릴게요."); init(37.5665,126.9780,"서울(기본)"); },
    { enableHighAccuracy:false, timeout:8000, maximumAge:300000 }
  );
}

// Slow-load hint after 4s
setTimeout(()=>{
  if(!state.data){
    document.getElementById('locLabel').textContent = "네트워크가 느려요… 잠시만요";
  }
}, 4000);

// UI handlers
const panel = document.getElementById('settingsPanel');
const overlay = document.getElementById('overlay');
function togglePanel(open){
  if(open===undefined) open = !panel.classList.contains('open');
  panel.classList.toggle('open', open);
  overlay.classList.toggle('show', open);
}
document.getElementById('settingsBtn').addEventListener('click',()=>togglePanel());
overlay.addEventListener('click',()=>togglePanel(false));

document.getElementById('tgToday').addEventListener('click',()=>{state.view='today';document.getElementById('tgToday').classList.add('active');document.getElementById('tgTomorrow').classList.remove('active'); if(state.data) render();});
document.getElementById('tgTomorrow').addEventListener('click',()=>{state.view='tomorrow';document.getElementById('tgTomorrow').classList.add('active');document.getElementById('tgToday').classList.remove('active'); if(state.data) render();});
document.getElementById('btnRefresh').addEventListener('click',()=>useGeolocation());
document.getElementById('retryBtn').addEventListener('click',()=>useGeolocation());
document.getElementById('langSelect').addEventListener('change',(e)=>{state.lang=e.target.value; toast("언어 설정은 지명/문장에 반영됩니다."); if(state.locationName){ document.getElementById('locLabel').textContent="지명 새로고침 중…"; } if(navigator.geolocation) navigator.geolocation.getCurrentPosition((pos)=> fetchLocationName(pos.coords.latitude,pos.coords.longitude,state.lang).then(name=>{ if(name){ state.locationName=name; document.getElementById('locLabel').textContent=name; } })); if(state.data) render(); });
document.getElementById('toneSelect').addEventListener('change',(e)=>{state.tone=e.target.value; if(state.data) render();});

// Start
useGeolocation();
</script>
</body>
</html>
